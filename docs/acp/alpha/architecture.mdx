---
title: Architecture
description: "Understand core ACP architecture"
---

This page serves as a placeholder for our upcoming detailed architecture documentation. We will soon provide a comprehensive overview of our design approach for agent-to-agent communication and the protocol architecture.

In the meantime, we invite the community to actively participate in shaping key architectural decisions through focused discussions. The following discussion topics cover some of the most challenging and critical aspects of agent communication and protocol establishment:

## Community Discussions

Join the conversations on GitHub:

- [Support for Stateful Agents](https://github.com/i-am-bee/beeai/discussions/322)

Pending topics:

- **Natural Language as an Agent Interface** _(pending creation)_
- **Choosing between REST and JSON-RPC for Communication** _(pending creation)_
- **WebSockets vs HTTP vs Peer-to-Peer (Full Duplex Communication)** _(pending creation)_
- **Integration of Legacy Software with Agent Protocols** _(pending creation)_
- **Streaming Data between Agents** _(pending creation)_
- **Handling Request Cancellation and Ensuring Persistency** _(pending creation)_
- **Agent and Tool Providers versus MCP Servers: Roles and Responsibilities** _(pending creation)_
- **Deployment Strategies for Agents** _(pending creation)_
- **Configuration and Model Dependency Management for Agents** _(pending creation)_
- **Agent Discoverability without Runtime** _(pending creation)_

## Support for Stateful Agents

üí¨ [GitHub Discussion](https://github.com/i-am-bee/beeai/discussions/322)

### Motivation

Supporting both stateless and stateful agents enables ACP to handle a broader range of use cases, particularly complex or long-lived interactions requiring persistent context. Such agents can offer more natural, efficient, and sophisticated user experiences. The following are some agent examples:

- [aider](https://beeai.dev/agents/aider): Agent designed for collaborative AI-assisted programming with integrated file system support.
- `supervisor`: A long-lived agent managing multi-step tasks.
- Interactive agents involving continuous human-agent interactions while maintaining conversational context.

### Stateless vs Stateful Agents

| Area                           | Stateless Agents | Stateful Agents               |
| ------------------------------ | ---------------- | ----------------------------- |
| Scalability and load balancing | ‚úÖ Easy          | ‚ùå Difficult                  |
| Complexity of interaction      | ‚ùå Low           | ‚úÖ High                       |
| Communication efficiency       | ‚ùå Low           | ‚úÖ High (incremental changes) |
| Failure, interruption recovery | ‚úÖ Easy          | ‚ùå Difficult                  |
| Agent complexity               | ‚úÖ Low           | ‚ùå High (state management)    |

### Problem

ACP currently supports both stateful and stateless agents. Stateful agents utilize agent templates, but this feature is currently undocumented. The transport mechanisms (e.g., SSE, WebSockets) inherently maintain stateful connections, raising questions about the adequacy and clarity of the existing implementation. This implementation must be clearly evaluated and documented.

Selecting appropriate transport mechanisms is critical. Incorporating stateful behavior should not overly complicate ACP nor compromise its scalability and performance.

#### Current Stateless Implementation

The agent author provides a single method to instantiate, run, and destroy an agent:

```json
{
  "id": "msg-001",
  "jsonrpc": "2.0",
  "method": "agents/run",
  "params": {
    "name": "agent-name",
    "input": { "prompt": "Hello world" }
  }
}
```

#### Current Stateful Implementation

The agent author provides three separate methods: `create`, `run` and `destroy` of an agent. The `create` method returns an instance ID, generated by the agent provider. The `run` method can be called repeatedly.

**Create:**

```json
{
  "id": "msg-001",
  "jsonrpc": "2.0",
  "method": "agents/create",
  "params": { "templateName": "agent-name", "config": {} }
}
```

**Run:**

```json
{
  "id": "msg-002",
  "jsonrpc": "2.0",
  "method": "agents/run",
  "params": {
    "name": "agent-name-001",
    "input": { "prompt": "Hello world" }
  }
}
```

**Destroy:**

```json
{
  "id": "msg-003",
  "jsonrpc": "2.0",
  "method": "agents/destroy",
  "params": { "name": "agent-name-001" }
}
```

### Open Questions

- Is the current stateful implementation (session = agent instance) sufficient for all use cases?
- Is the current stateless implementation well-documented, can statelessness be enforced by design?
- Transport consequences - REST (stateless) vs long-lived SSE (stateful) vs websocket (stateful)? Consider progressive enhancement?
- Should standardized headers or metadata be adopted?
- Mechanisms for restartable or recoverable connections?
- Strategies for automated resource cleanup when stateful agents are no longer in use?
- Provide OOTB support for key-value storage?

### Alternative Proposal

Passing `sessionId` through `_meta` object.

```json
{
  "id": "msg-001",
  "jsonrpc": "2.0",
  "method": "agents/run",
  "params": {
    "name": "agent-name",
    "input": { "prompt": "Hello world" },
    "_meta": {
      "sessionId": "session-123"
    }
  }
}
```

### Goal

ACP should flexibly support stateful and stateless agents while maintaining simplicity and scalability.

Specifically, ACP should:

- Keep protocol-level statefulness minimal, without requiring persistent state management within the protocol itself.
- Provide standardized mechanisms for agents to optionally manage context and state.
- Delegate responsibility for persistent state management and resource cleanup explicitly to agent implementations.

### Additional Resources

- [Langgraph - Persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/)
- [Llama stack - Agents API](https://github.com/meta-llama/llama-stack/blob/main/llama_stack/apis/agents/agents.py)
- [MCP discussion - State, and long-lived vs. short-lived connections](https://github.com/modelcontextprotocol/specification/discussions/102)
